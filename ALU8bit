`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 18.09.2025 19:08:12
// Design Name: 
// Module Name: ALU8bit
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////
//inputs : a,b,op,en
//output: result,carryout 

//Arithmetric
//operand 0000 - addition
//op 0001 - subtraction
//op 0010-multiplication
//op 0011-division

//bitwise operation - left shift, right shift

//logical operation - and or nand nor xor xnor 

//comparator - equality check greater , lesser






module ALU8bit(input wire[7:0]a,b, input wire[3:0]op ,input enable,output reg[15:0] result);

reg [15:0]ALU_result; //wire output result is to be updated to this register.


always@(*)begin
case(op)
    4'b0000: ALU_result = a + b;
    4'b0001: ALU_result = a - b;
    4'b0010: ALU_result = a*b;
    4'b0011: ALU_result = (b!=0)? a/b : 16'b0;   //division with zero guard
    //bitwise logical shifts : >> or  << , arithmetic : <<< , >>> 
    // signed vs unsigned , take a as 101101001;
    4'b0100: ALU_result = a<<1;
    4'b0101: ALU_result = a>>1;
    4'b0110: ALU_result = a<<<1;
    4'b0111: ALU_result = a>>>1;
    //logical
    4'b1000: ALU_result = a&b ;  //and
    4'b1001: ALU_result = a|b;   //or
    4'b1010: ALU_result = ~(a&b);    //nand
    4'b1011: ALU_result = ~(a|b);    //nor
    4'b1100: ALU_result = a^b;       //xor
    4'b1101: ALU_result = ~(a^b);    //xnor
    //comaparator
    4'b1110: ALU_result = (a==b)? 16'b1:16'b0;   
default: ALU_result = 16'b0;
endcase
result = enable? ALU_result : 16'b0;
end
endmodule
